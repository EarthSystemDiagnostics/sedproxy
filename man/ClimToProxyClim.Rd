% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ClimToProxyClim.R
\name{ClimToProxyClim}
\alias{ClimToProxyClim}
\title{Simulate sediment archived proxy records from an "assumed true"
climate signal.}
\usage{
ClimToProxyClim(clim.signal, timepoints,
  proxy.calibration.type = c("identity", "UK37", "MgCa"),
  smoothed.signal.res = 100, seas.prod = rep(1/ncol(clim.signal),
  ncol(clim.signal)), bio.depth = 10, sed.acc.rate = 50, layer.width = 1,
  meas.noise = 0, meas.bias = 0, n.samples = Inf, n.replicates = 1)
}
\arguments{
\item{clim.signal}{The "assumed true" climate signal, e.g. climate model
output or instrumental record. A \code{\link{ts}} object consisting of a
years x 12 (months) x n habitats (e.g. depths) matrix of temperatures. The
time series should be at annual resolution and in reverse, i.e. "most
recent timepoint first" order.}

\item{timepoints}{The timepoints for which the proxy record is to be modelled}

\item{proxy.calibration.type}{Type of proxy, e.g. Uk'37 or MgCa, to which the
clim.signal is converted before the archiving and measurement of the proxy
is simulated}

\item{smoothed.signal.res}{The resolution, in years, of the smoothed (block
averaged) version of the input climate signal returned for plotting. This
does not affect what the proxy model uses as input. If set to NA, no
smoothed climate output is generated, this can speed up some simulations.}

\item{seas.prod}{The seasonal pattern of productivity for the organism(s)
archived in the proxy. A vector of values with length equal to the number
of columns in the input climate signal matrix. i.e. 1 weight for each month
x habitat combination. Defaults to a vector of equal weights.}

\item{bio.depth}{Depth of the bioturbated layer in cm, defaults to 10 cm. If
bio.depth == 0, each timepoint samples from a single year of the
clim.signal, equivalent to sampling a laminated sediment core.}

\item{sed.acc.rate}{Sediment accumulation rate in cm per 1000 years. Defaults
to 50 cm per ka. Either a single value, or vector of same length as
"timepoints"}

\item{layer.width}{the width of the sediment layer from which samples were
taken, e.g. foraminifera were picked or alkenones were extracted, in cm.
Defaults to 1 cm.}

\item{meas.noise}{The amount of noise to add to each simulated proxy value.
Defined as the standard deviation of a normal distribution with mean = 0}

\item{meas.bias}{The amount of bias to add to each simulated proxy
time-series. Each replicate proxy time-series has a constant bias added,
drawn from a normal distribution with mean = 0, sd = meas.bias. Bias
defaults to zero.}

\item{n.samples}{Number of e.g. Foraminifera sampled per timepoint, this can
be either a single number, or a vector of length = timepoints}

\item{n.replicates}{Number of replicate proxy time-series to simulate from
the climate signal}
}
\value{
\code{ClimToProxyClim} returns a list with three elements:
\enumerate{
\item a dataframe \code{simulated.proxy} 2. a dataframe \code{smoothed.signal}
\item a list \code{everything}
}

The dataframe \code{simulated.proxy} contains a single realisation of the
final forward modelled proxy, as well as the intermediate stages and the
original climate signal at the requested timepoints.

The dataframe \code{smoothed.signal} contains a block averaged version the
input climate signal, defaults to 100 year means but this is set by the
parameter smoothed.signal.res. This is useful for plotting against the
resulting simulated proxy.

The list \code{everything} contains all of the above, but where a stage
contains stochastically generated noise, rather than a vector, a
\code{timepoints} \strong{by} \code{n.replicates} matrix is returned.

\strong{Named elements of the returned proxy record:}

\tabular{ll}{ \bold{Variable} \tab \bold{Description} \cr timepoints
\tab requested timepoints
\cr clim.timepoints.ssr \tab means of climate signal at resolution =
smoothed.signal.res evaluated at the requested timepoints
\cr proxy.bt               \tab proxy after bioturbation
\cr proxy.bt.sb              \tab proxy after bioturbation + seasonal bias
\cr sed.acc.rate               \tab sediment accumulation rates for each
timepoint
\cr smoothing.width            \tab weighted mean time span represented in a
sample after bioturbation
\cr proxy.bt.sb.sampY             \tab proxy after bioturbation, seasonal bias
and finite sampling of years but not seasonality
\cr proxy.bt.sb.sampYM             \tab proxy after bioturbation, seasonal
bias and finite sampling of years and months
\cr proxy.bt.sb.inf.b            \tab proxy after bioturbation, seasonal bias
and calibration bias
\cr proxy.bt.sb.inf.b.n          \tab proxy after bioturbation, seasonal bias,
calibration bias and measurement noise
\cr proxy.bt.sb.sampYM.b           \tab proxy after bioturbation, seasonal
bias, finite sampling and calibration bias
\cr proxy.bt.sb.sampYM.b.n         \tab proxy after bioturbation, seasonal
bias, finite sampling, calibration bias and measurement noise
\cr simulated.proxy            \tab final simulated proxy, this will be same
as proxy.bt.sb.inf.b.n when n.samples = Inf, and proxy.bt.sb.sampYM.b.n when
n.samples is finite }
}
\description{
\code{ClimToProxyClim} simulates the creation of a proxy climate
record from a climate signal that is assumed to be true.

The following aspects of proxy creation are currently modelled.
\enumerate{
\item Seasonal bias in the encoding of a proxy due to the interaction between
climate seasonality and any seasonality in the life cycle of the organism
encoding the climate signal (e.g. Foraminifera for Mg/Ca ratios, or
phytoplankton for Alkenone unsaturation indices).
\item Bioturbation of the sediment archived proxy. For each requested
timepoint, the simulated proxy consists of a weighted mean of the climate
signal over a time window that is determined by the sediment accumulation
rate {sed.acc.rate} and the bioturbation depth {bio.depth} which defaults
to 10 cm. The weights are given by the depth solution to an impulse
response function (Berger and Heath, 1968).
\item Aliasing of seasonal and inter-annual climate variation onto to
bioturbated (smoothed) signal. For proxies measured on a small number of
discrete particles both seasonal and inter-annual climate variation is
aliased into the proxy record. For example, Foraminifera have a life-cycle
of approximately 1 month, so they record something like the mean
temperature from a single month. If Mg/Ca is measured on e.g.
\code{n.samples} = 30 individuals, the measured proxy signal is a mean of
30 distinct monthly mean temperatures and will thus be a stochastic sample
of the true mean climate.
\item Measurement noise/error is added as a pure Gaussian white noise process
with mean = 0, standard deviation = \code{meas.noise}.
\item Additionally, a random \emph{bias} can be added to each realisation of a
proxy record. Bias is simulated as a Gaussian random variable with mean =
0, standard deviation = \code{meas.bias}. The same randomly generated bias
value is applied to all timepoints in a simulated proxy record, when
multiple replicate proxies are generated ({n.replicates} > 1) each
replicate has a different bias applied.
}

\code{ClimToProxyClim} returns one or more replicates of the final
simulated proxy as well as several intermediate stages (see section
\strong{Value} below).
}
\examples{
library(ggplot2)
set.seed(26052017)
clim.in <- ts(N41.t21k.climate[nrow(N41.t21k.climate):1,] - 273.15, start = -39)

PFM <- ClimToProxyClim(clim.signal = clim.in,
                       timepoints = round(N41.proxy$Published.age),
                       proxy.calibration.type = "identity",
                       seas.prod = N41.G.ruber.seasonality,
                       sed.acc.rate = N41.proxy$Sed.acc.rate.cm.ka,
                       layer.width = 1,
                       meas.noise = 0.46, n.samples = Inf,
                       smoothed.signal.res = 10, meas.bias = 1,
                       n.replicates = 10)

PlotPFMs(PFM$everything, max.replicates = 1, stage.order = "seq") +
  facet_wrap(~stage)

PlotPFMs(PFM$everything, max.replicates = 1, stage.order = "var")

PlotPFMs(PFM$everything, stage.order = "var", plot.stages = "all")

}
