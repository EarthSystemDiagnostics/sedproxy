% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ClimToProxyClim.ts.R
\name{ClimToProxyClim.ts}
\alias{ClimToProxyClim.ts}
\title{Simulate sediment archived proxy records from an "assumed true" climate signal.}
\usage{
ClimToProxyClim.ts(clim.signal, timepoints,
  proxy.calibration.type = c("identity", "UK37", "MgCa"),
  smoothed.signal.res = 100, seas.prod = rep(1, 12), bio.depth = 10,
  sed.acc.rate = 50, layer.width = 1, meas.noise = 0, meas.bias = 0,
  n.samples = Inf, n.replicates = 1)
}
\arguments{
\item{clim.signal}{The "assumed true" climate signal, e.g. climate model output or
instrumental record. A years x 12 (months) matrix of temperatures.}

\item{timepoints}{The timepoints for which the proxy record is to be modelled}

\item{proxy.calibration.type}{Type of proxy, e.g. UK37 or MgCa, to which the clim.signal is
converted before the archiving and measurement of the proxy is simulated}

\item{smoothed.signal.res}{The resolution, in years, of the smoothed
(block averaged) version of the input climate signal returned for plotting.
This does not affect what the proxy model uses as input. If set to NA, no smoothed
climate output is generated, this can speed up some simulations.}

\item{seas.prod}{The seasonal pattern of productivity for the organism(s)
archived in the proxy. A vector of 12 values. Defaults to a uniform seasonal
distribution.}

\item{bio.depth}{Depth of the bioturbated layer in cm, defaults to 10 cm. If
bio.depth == 0, each timepoint samples from a single year of the clim.signal,
equivalent to sampling a laminated sediment core.}

\item{sed.acc.rate}{Sediment accumulation rate in cm per 1000 years. Defaults
to 50 cm per ka. Either a single value, or vector of same
length as "timepoints"}

\item{layer.width}{the width of the sediment layer from which samples were taken
e.g. foraminifera were picked or alkenones were extracted, in cm.}

\item{meas.noise}{The amount of noise to add to each simulated proxy value.
Defined as the standard deviation of a normal distribution with mean = 0}

\item{meas.bias}{The amount of bias to add to each simulated proxy
time-series. Each replicate proxy time-series has a constant bias added,
drawn from a normal distribution with mean = 0, sd = meas.bias. Bias
defaults to zero.}

\item{n.samples}{Number of e.g. Foraminifera sampled per timepoint, this can
be either a single number, or a vector of length = timepoints}

\item{n.replicates}{Number of replicate proxy time-series to simulate from
the climate signal}
}
\value{
\code{ClimToProxyClim} returns a list with three elements:
\enumerate{
\item a dataframe \code{simulated.proxy}
\item a dataframe \code{smoothed.signal}
\item a list \code{everything}
}

The dataframe \code{simulated.proxy} contains a single realisation of the
final forward modelled proxy, as well as the intermediate stages and the
original climate signal at the requested timepoints.

The dataframe \code{smoothed.signal} contains a block averaged version the
input climate signal, defaults to 100 year means but this is set by the parameter
smoothed.signal.res. This is useful for plotting against the resulting simulated
proxy.

The list \code{everything} contains all of the above, but where a stage contains stochastically
generated noise, rather than a vector, a \code{timepoints} \strong{by} \code{n.replicates} matrix is returned.

\strong{Named elements of the returned proxy record:}

\tabular{ll}{
\bold{Variable} \tab \bold{Description} \cr
timepoints                 \tab requested timepoints                                                                                                               \cr
clim.timepoints.ssr \tab means of climate signal at resolution = smoothed.signal.res evaluated at the requested timepoints                                                             \cr
proxy.bt               \tab proxy after bioturbation                                                                                                           \cr
proxy.bt.sb              \tab proxy after bioturbation + seasonal bias                                                                                           \cr
sed.acc.rate               \tab sediment accumulation rates for each timepoint                                                                                     \cr
smoothing.width            \tab weighted mean time span represented in a sample after bioturbation                                                                 \cr
proxy.bt.sb.sampY             \tab proxy after bioturbation, seasonal bias and finite sampling of years but not seasonality                                                                        \cr
proxy.bt.sb.sampYM             \tab proxy after bioturbation, seasonal bias and finite sampling of years and months                                                                        \cr
proxy.bt.sb.inf.b            \tab proxy after bioturbation, seasonal bias and calibration bias                                                                       \cr
proxy.bt.sb.inf.b.n          \tab proxy after bioturbation, seasonal bias, calibration bias and measurement noise                                                    \cr
proxy.bt.sb.sampYM.b           \tab proxy after bioturbation, seasonal bias, finite sampling and calibration bias                                                      \cr
proxy.bt.sb.sampYM.b.n         \tab proxy after bioturbation, seasonal bias, finite sampling, calibration bias and measurement noise                                   \cr
simulated.proxy            \tab final simulated proxy, this will be same as proxy.bt.sb.inf.b.n when n.samples = Inf, and proxy.bt.sb.sampYM.b.n when n.samples is finite
}
}
\description{
Simulate sediment archived proxy records from an "assumed true" climate signal.
}
\examples{
library(ggplot2)
set.seed(26052017)
clim.in <- N41.t21k.climate[(nrow(N41.t21k.climate)-40):1, ] - 273.15
clim.in.ts <- ts(N41.t21k.climate[(nrow(N41.t21k.climate)):1, ] - 273.15, start = -39)

tpts <- c(1, round(N41.proxy$Published.age), 21*1000)
#'tpts <- 10000
n.samps <- round(runif(length(tpts), 10, 40))
sed.acc.rates <- c(25, N41.proxy$Sed.acc.rate.cm.ka, 25)
#'sed.acc.rates <- 505+pi
system.time({
  set.seed(1)
  PFM <- ClimToProxyClim(clim.signal = clim.in,
                         timepoints = tpts,
                         proxy.calibration.type = "identity",
                         seas.prod = N41.G.ruber.seasonality,
                         sed.acc.rate = sed.acc.rates,
                         meas.noise = 0.46, n.samples = n.samps,
                         smoothed.signal.res = 100, meas.bias = 1,
                         n.replicates = 10)
})

system.time({
  set.seed(1)
  PFM.ts <- ClimToProxyClim.ts(clim.signal = clim.in.ts,
                               timepoints = tpts,
                               proxy.calibration.type = "identity",
                               seas.prod = N41.G.ruber.seasonality,
                               sed.acc.rate = sed.acc.rates,
                               layer.width = 0,
                               meas.noise = 0.46, n.samples = n.samps,
                               smoothed.signal.res = 100, meas.bias = 1,
                               n.replicates = 10)
})

PlotPFMs(PFM$everything, max.replicates = 1, stage.order = "seq") +
  facet_wrap(~stage)

PlotPFMs(PFM.ts$everything, max.replicates = 1, stage.order = "seq") +
  facet_wrap(~stage)

table(PFM$simulated.proxy$simulated.proxy - PFM.ts$simulated.proxy$simulated.proxy)
table(PFM$simulated.proxy$proxy.bt - PFM.ts$simulated.proxy$proxy.bt)

plot(PFM$simulated.proxy$simulated.proxy, PFM.ts$simulated.proxy$simulated.proxy)
abline(0,1)

sub <- PFM.ts$smoothed.signal \%>\%
  filter(timepoints > 0)

plot(PFM$smoothed.signal$value, sub$value)
table(PFM$smoothed.signal$value - sub$value)

plot(PFM$simulated.proxy$clim.timepoints.ssr, PFM.ts$simulated.proxy$clim.timepoints.ssr)
table((PFM$simulated.proxy$clim.timepoints.ssr - PFM.ts$simulated.proxy$clim.timepoints.ssr) == 0)
}
